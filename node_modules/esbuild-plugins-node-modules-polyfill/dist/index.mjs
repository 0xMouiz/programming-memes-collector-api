var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/tsup/assets/esm_shims.js
import { fileURLToPath } from "url";
import path from "path";
var getFilename = /* @__PURE__ */ __name(() => fileURLToPath(import.meta.url), "getFilename");
var getDirname = /* @__PURE__ */ __name(() => path.dirname(getFilename()), "getDirname");
var __dirname = /* @__PURE__ */ getDirname();

// src/lib/utils/util.ts
var escapeRegex = /* @__PURE__ */ __name((str) => {
  return str.replace(/[$()*+.?[\\\]^{|}]/g, "\\$&").replace(/-/g, "\\x2d");
}, "escapeRegex");
var commonJsTemplate = /* @__PURE__ */ __name(({ importPath }) => {
  return `export * from '${importPath}'`;
}, "commonJsTemplate");
var normalizeNodeBuiltinPath = /* @__PURE__ */ __name((path3) => {
  return path3.replace(/^node:/, "").replace(/\/$/, "");
}, "normalizeNodeBuiltinPath");

// src/lib/plugin.ts
import { builtinModules as builtinModules2 } from "node:module";
import path2 from "node:path";

// src/lib/polyfill.ts
import { builtinModules } from "node:module";
import { resolve, join } from "node:path";
import { build } from "esbuild";
import { loadPackageJSON, resolveModule } from "local-pkg";
import { resolve as resolveExports } from "resolve.exports";
async function polyfillPath(importPath) {
  if (!builtinModules.includes(importPath))
    throw new Error(`Node.js does not have ${importPath} in its builtin modules`);
  const jspmPath = resolve(
    __require.resolve(`@jspm/core/nodelibs/${importPath}`),
    // ensure "fs/promises" is resolved properly
    "../../.." + (importPath.includes("/") ? "/.." : "")
  );
  const jspmPackageJson = await loadPackageJSON(jspmPath);
  const exportPath = resolveExports(jspmPackageJson, `./nodelibs/${importPath}`, {
    browser: true
  });
  const exportFullPath = resolveModule(join(jspmPath, exportPath?.[0] ?? ""));
  if (!exportPath || !exportFullPath) {
    throw new Error(
      "resolving failed, please try creating an issue in https://github.com/imranbarbhuiya/esbuild-plugins-node-modules-polyfill"
    );
  }
  return exportFullPath;
}
__name(polyfillPath, "polyfillPath");
var polyfillPathCache = /* @__PURE__ */ new Map();
var getCachedPolyfillPath = /* @__PURE__ */ __name((importPath) => {
  const normalizedImportPath = normalizeNodeBuiltinPath(importPath);
  const cachedPromise = polyfillPathCache.get(normalizedImportPath);
  if (cachedPromise) {
    return cachedPromise;
  }
  const promise = polyfillPath(normalizedImportPath);
  polyfillPathCache.set(normalizedImportPath, promise);
  return promise;
}, "getCachedPolyfillPath");
var polyfillContentAndTransform = /* @__PURE__ */ __name(async (importPath) => {
  const exportFullPath = await getCachedPolyfillPath(importPath);
  const content = (await build({
    write: false,
    format: "esm",
    bundle: true,
    entryPoints: [exportFullPath]
  })).outputFiles[0].text;
  return content.replace(/eval\(/g, "(0,eval)(");
}, "polyfillContentAndTransform");
var polyfillContentCache = /* @__PURE__ */ new Map();
var getCachedPolyfillContent = /* @__PURE__ */ __name((_importPath) => {
  const normalizedImportPath = normalizeNodeBuiltinPath(_importPath);
  const cachedPromise = polyfillContentCache.get(normalizedImportPath);
  if (cachedPromise) {
    return cachedPromise;
  }
  const promise = polyfillContentAndTransform(normalizedImportPath);
  polyfillContentCache.set(normalizedImportPath, promise);
  return promise;
}, "getCachedPolyfillContent");

// src/lib/plugin.ts
var NAME = "node-modules-polyfills";
var loader = /* @__PURE__ */ __name(async (args) => {
  try {
    const isCommonjs = args.namespace.endsWith("commonjs");
    const resolved = await getCachedPolyfillPath(args.path);
    const resolveDir = path2.dirname(resolved);
    if (isCommonjs) {
      return {
        loader: "js",
        contents: commonJsTemplate({
          importPath: args.path
        }),
        resolveDir
      };
    }
    const contents = await getCachedPolyfillContent(args.path);
    return {
      loader: "js",
      contents,
      resolveDir
    };
  } catch (error) {
    console.error("node-modules-polyfill", error);
    return {
      contents: `export {}`,
      loader: "js"
    };
  }
}, "loader");
var nodeModulesPolyfillPlugin = /* @__PURE__ */ __name((options = {}) => {
  const { globals = {}, namespace = NAME, name = NAME } = options;
  if (namespace.endsWith("commonjs")) {
    throw new Error(`namespace ${namespace} must not end with commonjs`);
  }
  const commonjsNamespace = `${namespace}-commonjs`;
  return {
    name,
    setup: ({ onLoad, onResolve, initialOptions }) => {
      if (initialOptions.define && !initialOptions.define.global) {
        initialOptions.define.global = "globalThis";
      } else if (!initialOptions.define) {
        initialOptions.define = { global: "globalThis" };
      }
      initialOptions.inject = initialOptions.inject ?? [];
      if (globals.Buffer) {
        initialOptions.inject.push(path2.resolve(__dirname, "../globals/Buffer.js"));
      }
      if (globals.process) {
        initialOptions.inject.push(path2.resolve(__dirname, "../globals/process.js"));
      }
      onLoad({ filter: /.*/, namespace }, loader);
      onLoad({ filter: /.*/, namespace: commonjsNamespace }, loader);
      const filter = new RegExp(`(?:node:)?${builtinModules2.map(escapeRegex).join("|")}`);
      const resolver = /* @__PURE__ */ __name(async (args) => {
        const ignoreRequire = args.namespace === commonjsNamespace;
        const pollyfill = await getCachedPolyfillPath(args.path).catch(() => null);
        if (!pollyfill) {
          return;
        }
        const isCommonjs = !ignoreRequire && args.kind === "require-call";
        return {
          namespace: isCommonjs ? commonjsNamespace : namespace,
          path: args.path
        };
      }, "resolver");
      onResolve({ filter }, resolver);
    }
  };
}, "nodeModulesPolyfillPlugin");
export {
  commonJsTemplate,
  escapeRegex,
  nodeModulesPolyfillPlugin,
  normalizeNodeBuiltinPath
};
/**
 * `polyfillPath` and `getCachedPolyfillContent` are taken from below source with some modifications for my use case.
 * https://github.com/Aslemammad/modern-node-polyfills
 * @author Aslemammad
 * @license MIT
 */
//# sourceMappingURL=index.mjs.map