/**
 * @remix-run/dev v1.18.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var execa = require('execa');
var pidtree = require('pidtree');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var execa__default = /*#__PURE__*/_interopDefaultLegacy(execa);
var pidtree__default = /*#__PURE__*/_interopDefaultLegacy(pidtree);

let isWindows = process.platform === "win32";
let kill = async pid => {
  try {
    let cmd = isWindows ? ["taskkill", "/F", "/PID", pid.toString()] : ["kill", "-9", pid.toString()];
    await execa__default["default"](cmd[0], cmd.slice(1));
  } catch (error) {
    throw new Error(`Failed to kill process ${pid}: ${error}`);
  }
};
let isAlive = pid => {
  try {
    process.kill(pid, 0);
    return true;
  } catch (error) {
    return false;
  }
};
let killtree = async pid => {
  let descendants = await pidtree__default["default"](pid);
  let pids = [pid, ...descendants];
  await Promise.all(pids.map(kill));
  return new Promise((resolve, reject) => {
    let check = setInterval(() => {
      let alive = pids.filter(isAlive);
      if (alive.length === 0) {
        clearInterval(check);
        resolve();
      }
    }, 50);
    setTimeout(() => {
      clearInterval(check);
      reject(new Error("Timeout: Processes did not exit within the specified time."));
    }, 2000);
  });
};

exports.kill = kill;
exports.killtree = killtree;
